#include "main.h"
#include "pros/misc.h"
#include "pros/rtos.hpp"
#include <cmath>
#include <cstdio>

pros::Controller master(pros::E_CONTROLLER_MASTER);
pros::MotorGroup left_mg({-15, -16, 11});
pros::MotorGroup right_mg({12, 13, -14});



pros::Motor Hood(6);
pros::Motor Storage(2);
pros::Motor Top(3);
pros::Motor Front(4);

pros::Imu inertial(19);
pros::Rotation xrot(2);
pros::Rotation yrot(1);
pros::ADIDigitalOut ML('H');
pros::ADIDigitalOut Hook('E');
pros::ADIDigitalOut agi('A');

static double botx = 0.0; //placeholer values (need do decide start position)
static double boty = 0.0;
static double both = 0.0;
static double starting_heading = 0.0;

// A = left side of the park zone in the back
const int startAx = 0; //need to test dis is placeholder )
const int startAy = 0;
const int startAang = 0;

// B = left side of the park zone in the front
const int startBx = 0; //need to test dis is placeholder )
const int startBy = 0;
const int startBang = 0;

// C = right side of the park zone in the fornt
const int startCx = 0; //need to test dis is placeholder )
const int startCy = 0;
const int startCang = 0;

// D = right side of the park zone in the back
const int startDx = 0; //need to test dis is placeholder )
const int startDy = 0;
const int startDang = 0;


static double debug_turn_error = 0.0;
static double debug_turn_power = 0.0;
// middle goal is (0,0)
// heading 0 is facing perpendicular to field wall

//.05 tkd
//3.5 tkp

const int ekp = 0;// need to tune dis
const int ekd = 0;

double saved_drive_error = 0.0;

double inith = 0.0;
double initv = 0.0;

double rad2deg = 180.0 / acos(-1.0);
double deg2rad = M_PI / 180.0;

double adjustment = .01; // need to tune dis

const double conversion_jerry2in = 36.0/35.0;

pros::Mutex odom_lock;

void updatepose(void* ignore){
    double prev_x = 0;
    double prev_y = 0;

    xrot.reset_position();
    yrot.reset_position();

    while(true) {
        // 1. Get Sensor Readings
        double curr_x = xrot.get_position(); 
        double curr_y = yrot.get_position();
        double curr_h = inertial.get_heading();


        if (std::isinf(curr_h) || std::isnan(curr_h)) {
             pros::lcd::print(0, "IMU RESETTING...");
             pros::delay(10);
             continue; 
        }


        double delta_x = (curr_x - prev_x) * (1.0/18000.0); 
        double delta_y = (curr_y - prev_y) * (1.0/18000.0);

        double theta = -curr_h * deg2rad; 
        
        odom_lock.take(TIMEOUT_MAX);

        botx += delta_x * cos(theta) - delta_y * sin(theta);
        boty += delta_x * sin(theta) + delta_y * cos(theta);
        both = curr_h + starting_heading;

        odom_lock.give();

        prev_x = curr_x;
        prev_y = curr_y;

        pros::lcd::print(0, "X: %.2f", botx);
        pros::lcd::print(1, "Y: %.2f", boty);
        pros::lcd::print(2, "H: %.2f", both);
		    pros::lcd::print(5, "Turn Err: %.2f", debug_turn_error);
        pros::lcd::print(6, "Power: %.2f", debug_turn_power);

        pros::delay(10); 
    }
}

void initialize() {
    pros::lcd::initialize();
    
    // 1. Reset the IMU
    inertial.reset(); 
    
    // 2. WAIT for calibration to finish (This is the missing piece)
    int time = 0;
    while(inertial.is_calibrating()) {
        pros::lcd::print(0, "IMU Calibrating... %d", time);
        pros::delay(20);
        time += 20;
    }
    pros::lcd::print(0, "IMU READY");

    // 3. Start Odometry and Reset other sensors
    pros::Task odometry_task_pose(updatepose, nullptr);
    left_mg.move_velocity(0);
    right_mg.move_velocity(0);
    Hood.move_velocity(0);
    Top.move_velocity(0);
    Front.move_velocity(0);
    Storage.move_velocity(0);
    xrot.reset();
    yrot.reset();
}

void disabled() {
}
void competition_initialize() {
}


static double vperc(double perc) {
	return (perc / 100.0) * 200.0;
}

void score_bottom(int vel, bool yn) {
	if (yn) {
		Front.move_velocity(-vperc(vel));
		Storage.move_velocity(-vperc(vel));
	} else {
		Front.move_velocity(0);
		Storage.move_velocity(0);
	}
}

void score_top(int vel, bool yn) {
	if (yn) {
		Front.move_velocity(vperc(vel));
		Storage.move_velocity(-vperc(vel));
		Hood.move_velocity(vperc(vel));
		Top.move_velocity(vperc(vel));
	} else {
		Front.move_velocity(0);
		Storage.move_velocity(0);
		Hood.move_velocity(0);
		Top.move_velocity(0);
	}
}

void score_mid(int vel, bool yn) {
	if (yn) {
		Front.move_velocity(vperc(vel));
		Storage.move_velocity(-vperc(vel));
		Top.move_velocity(-vperc(vel));
	} else {
		Front.move_velocity(0);
		Storage.move_velocity(0);
		Top.move_velocity(0);
	}
}

void intake(int vel, bool yn) {
	if (yn) {
		Front.move_velocity(vperc(vel));
		Storage.move_velocity(vperc(vel));
	} else {
		Front.move_velocity(0);
		Storage.move_velocity(0);
	}
}

void almost_top(int vel, bool yn) {
	if (yn) {
		Front.move_velocity(vperc(vel));
		Storage.move_velocity(-vperc(vel));
		Hood.move_velocity(-vperc(vel));
		Top.move_velocity(vperc(vel));
	} else {
		Front.move_velocity(0);
		Storage.move_velocity(0);
		Hood.move_velocity(0);
		Top.move_velocity(0);
	}
}

void opcontrol() {
	double isdone = 0;
	double speed = 1;
	while (true){
		int forward = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int turn = master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);

        int left_power = (forward - turn*-1) * speed;
        int right_power = (forward + turn*-1) * speed;

        left_mg.move(left_power);
        right_mg.move(right_power);


		if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L1)) {
            score_bottom(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L2)) {
            intake(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {
            score_top(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {
            score_mid(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {
            almost_top(100, true);
        } else {
            score_bottom(0, false);
            intake(0, false);
            score_top(0, false);
            score_mid(0, false);
            almost_top(0, false);
        }

        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_UP)) speed = 1.0;
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_RIGHT)) speed = 0.4;
        
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_X)) ML.set_value(false);
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_B)) ML.set_value(true);

		if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) Hook.set_value(true);
		if (master.get_digital(pros::E_CONTROLLER_DIGITAL_Y)) Hook.set_value(false);
		if (master.get_digital(pros::E_CONTROLLER_DIGITAL_LEFT)) agi.set_value(true);
		if (master.get_digital(pros::E_CONTROLLER_DIGITAL_DOWN)) agi.set_value(false);
		 
        pros::delay(30);	}
}


//odometry + PID :(
double normalise_angle(double angle) {
    angle = fmod(angle, 360.0);

    if (angle > 180.0)  angle -= 360.0;
    if (angle < -180.0) angle += 360.0;

    return angle;
}

double abs2(double value) {
	if (value < 0) {
		value = -1 * value;
	}
	return value;
}


void turn(double ang, double kd, double kp, double timeout) {
    left_mg.set_brake_mode(pros::E_MOTOR_BRAKE_HOLD);
    right_mg.set_brake_mode(pros::E_MOTOR_BRAKE_HOLD);
    
    double target_heading = normalise_angle(ang);
	double error = 0;
    double prev_error = 0;
    double derivative = 0;
    double tvel = 0;
    
    // Timer variables
    double starting_time = pros::millis();
    
    // Exit conditions
    int time_settled = 0; // How long we have been close to target
    double settle_threshold = 1.0; // 1 degree margin of error

    // DEBUG: Print that we are trying to turn
    pros::lcd::print(1, "Turn Start: %.2f", target_heading);

    while (true) {
        // SAFETY: If IMU disconnects, break out so motors don't lock up
        if(std::isinf(inertial.get_heading())){
             pros::lcd::print(0, "IMU DEAD - CHECK PORT 19");
             break;
        }

        double current_heading = inertial.get_heading();
        
        // Calculate Error
        error = target_heading - current_heading;
        error = normalise_angle(error);

        // Derivative
        derivative = error - prev_error;
        prev_error = error;

        // Calculate Output
        tvel = (error * kp) + (derivative * kd);

        // Apply to motors
        // Note: vperc converts to 200RPM max. 
        // If error is 90 and kp is 2, tvel is 180 (RPM). This is fast enough.
        left_mg.move_velocity(vperc(tvel));
        right_mg.move_velocity(vperc(-tvel));

        // Debug info on screen
        pros::lcd::print(2, "Err: %.2f  Out: %.2f", error, tvel);

        // EXIT CONDITION 1: Timeout
        if (pros::millis() - starting_time > timeout * 1000) {
            break;
        }

        // EXIT CONDITION 2: Reached Target (Settled)
        if (fabs(error) < settle_threshold) {
            time_settled += 1;
        } else {
            time_settled = 0;
        }



        // If we have been within 1 degree for 100ms, stop.
        if (time_settled > 5) {
            break;
        }

        pros::delay(20);
    }

    // Stop motors
    left_mg.move_velocity(0);
    right_mg.move_velocity(0);
    pros::lcd::print(1, "Turn Done");
}



void drive(double dis, double kd, double kp, double ekd, double ekp, double timeout) {
	double relerror = 0;
	double drive_correction = 0;
	double raw_dis = yrot.get_position()/1800.0;
	double sdis = raw_dis;
	int is_done = 0;
	int direction = 0;
	double distance_derivative_1 = 0;
	double distance_derivative_2 = 0;
	double distance_derivative_3 = 0;
	double smoothed_distance_derivative = 0;
	double starting_time = pros::millis();
	double target_reading = sdis + dis; 
	double error = target_reading - raw_dis;
	double old_error = error;
	while (is_done < 10) {
		if (fabs(error) > 0.01 && fabs(error) < 0.1) {
			is_done += 1;
		}

		if ((pros::millis() - starting_time) > timeout*1000) {
			break;
		}

		raw_dis = yrot.get_position()/1800.0;
		double target_reading = sdis + dis; 
		error = target_reading - raw_dis;

		distance_derivative_3 = distance_derivative_2;
        distance_derivative_2 = distance_derivative_1;
        distance_derivative_1 = (error - old_error)/0.02;
        smoothed_distance_derivative = (distance_derivative_1 + distance_derivative_2 + distance_derivative_3)/3;
		double tvel = error * kp + kd * smoothed_distance_derivative;

		pros::delay(20);

		left_mg.move_velocity(vperc(tvel));
		right_mg.move_velocity(vperc(tvel));

		old_error = error;
	}
	left_mg.move_velocity(0);
	right_mg.move_velocity(0);
}



void cordon(double x, double y, double dkd, double dkp, double tkd, double tkp, double theta, double dtimeout, double ttimeout) {
	double difx = x - botx;
	double dify = y - boty;
	double math_angle = std::atan2(dify, difx) * rad2deg;
	double desired_heading = 90 - math_angle;
	double desired_headingr = desired_heading - both;
	desired_headingr = normalise_angle(desired_headingr);
	double drive_distance = std::hypot(difx, dify);
	double reltheta = theta - inertial.get_heading() + starting_heading;
	reltheta = normalise_angle(reltheta);
	double drive_direction = 1;
	if(desired_headingr <= 90 && desired_headingr >= -90) {
		drive_direction = 1;
	} else {
		drive_direction = -1;
		desired_headingr = normalise_angle(desired_headingr + 180);
	}
	turn(desired_headingr, tkd, tkp, ttimeout);
	pros::delay(100);
	drive(drive_distance, dkd, dkp, ekp, ekd, dtimeout);
	if (theta != 0) {
		turn(reltheta, tkd, tkp, ttimeout);
	}
}


//auton

void safeauton(bool rb, bool lr) {
	double xdir = 1;
	double ydir = 1;
	double hdir = 1;
	if (rb == true && lr == false) {
		xdir = -1;
		ydir = -1;
		hdir = 1;
		//right red
		// MUST UPDATE BOT STARTING POSITION VAlUES, X = -44.822*conversion_jerry2in, Y = -17.533*conversion_jerry2in, H = 180
	} else if (rb == true && lr == true) {
		xdir = -1;
		ydir = 1;
		hdir = -1;
		//left red
		// MUST UPDATE BOT STARTING POSITION VAlUES, X = -44.822*conversion_jerry2in, Y = 17.533*conversion_jerry2in, H = -180
	} else if (rb == false && lr == false) {
		xdir = 1;
		ydir = 1;
		hdir = 1;
		//right blue
		// MUST UPDATE BOT STARTING POSITION VAlUES, X = 44.822*conversion_jerry2in, Y = 17.533*conversion_jerry2in, H = 180
	} else if (rb == false && lr == true) {
		xdir = 1;
		ydir = -1;
		hdir = -1;
		//left blue
		// MUST UPDATE BOT STARTING POSITION VAlUES, X = 44.822*conversion_jerry2in, Y = -17.533*conversion_jerry2in, H = -180
	}
	cordon(44.822*conversion_jerry2in*xdir, 47*conversion_jerry2in*ydir, .5, .5, .2, .2, -90*hdir, 3, 3);
	intake(100, true);
	ML.set_value(true);
	pros::delay(100);
	cordon(100000000*xdir, 47*conversion_jerry2in*ydir, .5, .5, .2, .2, -90*hdir, 4, 4);
	pros::delay(100);
	cordon(20*conversion_jerry2in*xdir, 47*conversion_jerry2in*ydir, .5, .5, .2, .2, 90, 4, 4);
	pros::delay(100);
	ML.set_value(false);
	cordon(30*conversion_jerry2in*xdir, 47*conversion_jerry2in*ydir, .5, .5, .2, .2, 0, 2.5, 2.5);
	pros::delay(100);
	intake(100, false);
	pros::delay(50);
	score_top(100, true);
}


void skillsauton() {
	//MUST UPDATE BOT STARTING POSITION VAlUES, X = -60.717, Y = -18.755, H = 90
	cordon(-46.404*conversion_jerry2in, -18.755*conversion_jerry2in, .5, .5, .2, .2, 90, 1, 1);
	intake(100, true);
	cordon(-25.26*conversion_jerry2in, -23.646*conversion_jerry2in, .5, .5, .2, .2, 0, 1, 1);
	ML.set_value(true);
	pros::delay(100);
	cordon(-12.283*conversion_jerry2in, -12.283*conversion_jerry2in, .5, .5, .2, .2, 0, 1.5, 1.5);
	intake(100, false);
	ML.set_value(false);
	score_mid(100, true);
	pros::delay(100);
	cordon(-48.185*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, .2, .2, 0, 2.5, 2.5);
	ML.set_value(true);
	pros::delay(100);
	intake(100, true);
	cordon(-10000*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(-20*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 90, 2.5, 2.5);
	ML.set_value(false);
	pros::delay(100);
	cordon(-29.845*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	intake(100, false);
	score_top(100, true);
	pros::delay(3000);
	score_top(100, false);
	cordon(-37.792*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(-31.985*conversion_jerry2in, -34.5*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(30.94*conversion_jerry2in, -34.5*conversion_jerry2in, .5, .5, 0, 0, 0, 5, 5);
	pros::delay(100);
	cordon(53.601*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	ML.set_value(true);
	pros::delay(100);
	intake(100, true);
	cordon(10000*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(20*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 90, 2.5, 2.5);
	pros::delay(100);
	ML.set_value(false);
	cordon(29.845*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	intake(100, false);
	score_top(100, true);
	pros::delay(3000);
	score_top(100, false);
	cordon(41.069*conversion_jerry2in, -46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(41.069*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 7.5, 2.5);
	ML.set_value(true);
	pros::delay(100);
	cordon(1000000*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 3, 2.5);
	pros::delay(100);
	cordon(20*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 90, 2.5, 2.5);
	pros::delay(100);
	ML.set_value(false);
	cordon(29.845*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	intake(100, false);
	score_top(100, true);
	pros::delay(3000);
	score_top(100, false);
	cordon(37.792*conversion_jerry2in, 46.962*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(31.985*conversion_jerry2in, 34.5*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(-31.985*conversion_jerry2in, 34.5*conversion_jerry2in, .5, .5, 0, 0, 0, 5, 2.5);
	pros::delay(100);
	cordon(-53.075*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	ML.set_value(true);
	pros::delay(100);
	intake(100, true);
	cordon(-1000*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 3, 2.5);
	pros::delay(100);
	cordon(-20*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 90, 2.5, 2.5);
	pros::delay(100);
	ML.set_value(false);
	cordon(-29.845*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	intake(100, false);
	score_top(100, true);
	pros::delay(3000);
	score_top(100, false);
	cordon(-38.46*conversion_jerry2in, 46.877*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(-38.46*conversion_jerry2in, 14.867*conversion_jerry2in, .5, .5, 0, 0, 0, 2.5, 2.5);
	pros::delay(100);
	cordon(-67.41*conversion_jerry2in, 0*conversion_jerry2in, .5, .5, 0, 0, 0, 10, 2.5);
}	

void autonomous() {
	turn(180, 10, 3, 2);
}
