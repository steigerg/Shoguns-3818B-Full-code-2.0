#include "main.h"
#include <cmath>
#include <cstdio>

pros::Controller master(pros::E_CONTROLLER_MASTER);
pros::MotorGroup left_mg({1, 2, 3});
pros::MotorGroup right_mg({-4, -5, -6});

pros::Motor Hood(7);
pros::Motor Storage(8);
pros::Motor Top(9);
pros::Motor Front(10);

pros::Imu inertial(11);
pros::Rotation xrot(12);
pros::Rotation yrot(13);
pros::ADIDigitalOut ML('A');

// Global variables for position
// Using volatile to ensure task updates are seen
volatile double botx = 0.0; //placeholer values (need do decide start position)
volatile double boty = 0.0;
volatile double both = 0.0;
static double starting_heading = 0.0;

// A = left side of the park zone in the back
const int startAx = 0; //need to test dis is placeholder )
const int startAy = 0;
const int startAang = 0;

// B = left side of the park zone in the front
const int startBx = 0; //need to test dis is placeholder )
const int startBy = 0;
const int startBang = 0;

// C = right side of the park zone in the fornt
const int startCx = 0; //need to test dis is placeholder )
const int startCy = 0;
const int startCang = 0;

// D = right side of the park zone in the back
const int startDx = 0; //need to test dis is placeholder )
const int startDy = 0;
const int startDang = 0;

// middle goal is (0,0)
// heading 0 is facing perpendicular to field wall

//.05 tkd
//3.5 tkp

const int ekp = 0;// need to tune dis
const int ekd = 0;

double saved_drive_error = 0.0;

double rad2deg = 180.0 / M_PI;
double deg2rad = M_PI / 180.0;

double adjustment = .01; // need to tune dis

const double conversion_jerry2in = 6.0/36.0;

// Task to track position
void updatepose(void* ignore){
    // local variables for delta calculation
    double prev_x = 0;
    double prev_y = 0;

    xrot.reset_position();
    yrot.reset_position();

    while(true) {
        // get current raw values
        double curr_x = xrot.get_position(); 
        double curr_y = yrot.get_position();
        double curr_h = inertial.get_heading();

        // calculate change
        double delta_x = (curr_x - prev_x) * (1.0/36000.0); // simple conversion placeholder
        double delta_y = (curr_y - prev_y) * (1.0/36000.0);

        // rotate to global coordinates
        double theta = -curr_h * deg2rad; 
        botx += delta_x * cos(theta) - delta_y * sin(theta);
        boty += delta_x * sin(theta) + delta_y * cos(theta);
        both = curr_h;

        prev_x = curr_x;
        prev_y = curr_y;

        // printf("X: %.2f Y: %.2f H: %.2f\n", botx, boty, both);
        pros::delay(10);
    }
}

void initialize() {
    pros::lcd::initialize();
    left_mg.move_velocity(0);
    right_mg.move_velocity(0);
    Hood.move_velocity(0);
    Top.move_velocity(0);
    Front.move_velocity(0);
    Storage.move_velocity(0);

    inertial.reset();
    while(inertial.is_calibrating()){
        printf("imu_sensor is calibrating");
        pros::delay(10);
    }
    xrot.reset_position();
    yrot.reset_position();

    pros::Task odometry_task_pose(updatepose, nullptr);
}

void disabled() {
}
void competition_initialize() {
    initialize();
}


static double vperc(double perc) {
    return (perc / 100.0) * 200.0;
}

void score_bottom(int vel, bool yn) {
    if (yn) {
        Front.move_velocity(-vperc(vel));
        Storage.move_velocity(-vperc(vel));
    } else {
        Front.move_velocity(0);
        Storage.move_velocity(0);
    }
}

void score_top(int vel, bool yn) {
    if (yn) {
        Front.move_velocity(vperc(vel));
        Storage.move_velocity(-vperc(vel));
        Hood.move_velocity(vperc(vel));
        Top.move_velocity(vperc(vel));
    } else {
        Front.move_velocity(0);
        Storage.move_velocity(0);
        Hood.move_velocity(0);
        Top.move_velocity(0);
    }
}

void score_mid(int vel, bool yn) {
    if (yn) {
        Front.move_velocity(vperc(vel));
        Storage.move_velocity(-vperc(vel));
        Top.move_velocity(-vperc(vel));
    } else {
        Front.move_velocity(0);
        Storage.move_velocity(0);
        Top.move_velocity(0);
    }
}

void intake(int vel, bool yn) {
    if (yn) {
        Front.move_velocity(vperc(vel));
        Storage.move_velocity(-vperc(vel));
    } else {
        Front.move_velocity(0);
        Storage.move_velocity(0);
    }
}

void almost_top(int vel, bool yn) {
    if (yn) {
        Front.move_velocity(vperc(vel));
        Storage.move_velocity(-vperc(vel));
        Hood.move_velocity(-vperc(vel));
        Top.move_velocity(vperc(vel));
    } else {
        Front.move_velocity(0);
        Storage.move_velocity(0);
        Hood.move_velocity(0);
        Top.move_velocity(0);
    }
}

void opcontrol() {
    double speed = 1;
    while (true){
        double ly = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        double lx = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);
        
        // arcade drive
        left_mg.move_velocity(vperc((ly + lx) * speed));
        right_mg.move_velocity(vperc((ly - lx) * speed));

        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L1)) {
            score_bottom(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L2)) {
            intake(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {
            score_top(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {
            score_mid(100, true);
        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {
            almost_top(100, true);
        } else {
            // Stop everything if no buttons
            score_bottom(100, false);
            score_mid(100, false);
            intake(100, false);
            score_top(100, false);
        }

        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_UP)) {
            speed = 1.0;
        }
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_RIGHT)) {
            speed = 0.3;
        }
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_X)) {
            ML.set_value(false);
        }
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_B)) {
            ML.set_value(true);
        }

        pros::delay(20);
    }
}


//odometry + PID :(
void turn(double ang, double kd, double kp, double timeout) {
    double error = 0;
    double prev_error = 0;
    double derivative = 0;
    double starting_time = pros::millis();
    
    // Normalize target angle
    while (ang > 180) ang -= 360;
    while (ang < -180) ang += 360;

    int is_done = 0;

    while (is_done < 10){
        double Raw_angle = inertial.get_heading();
        
        // Calculate shortest path error
        error = ang - Raw_angle;
        while (error > 180) error -= 360;
        while (error < -180) error += 360;

        if (fabs(error) < 1.0){
            is_done = is_done + 1;
        } else {
            is_done = 0;
        }

        if ((pros::millis() - starting_time) > timeout*1000) {
            break;
        }

        derivative = error - prev_error;
        double tvel = kp * error + kd * derivative;

        left_mg.move_velocity(vperc(tvel));
        right_mg.move_velocity(vperc(-tvel));

        prev_error = error;
        pros::delay(20);
    }
    right_mg.move_velocity(0);
    left_mg.move_velocity(0);
}

// simple drive logic
void drive(double dis, double kd, double kp, double ekd, double ekp, double timeout) {
    left_mg.tare_position();
    right_mg.tare_position();
    
    double error = 0;
    double prev_error = 0;
    double derivative = 0;
    double starting_time = pros::millis();
    int is_done = 0;

    // convert inches to ticks if needed (placeholder conversion)
    double target_ticks = dis * 360.0 / (2.75 * M_PI); 

    while (is_done < 10) {
        double current_pos = (left_mg.get_position(0) + right_mg.get_position(0)) / 2.0;
        error = target_ticks - current_pos;

        if (fabs(error) < 10) { // low tolerance check
            is_done += 1;
        } else {
            is_done = 0;
        }

        if ((pros::millis() - starting_time) > timeout*1000) {
            break;
        }

        derivative = error - prev_error;
        double tvel = kp * error + kd * derivative;

        left_mg.move_velocity(vperc(tvel));
        right_mg.move_velocity(vperc(tvel));

        prev_error = error;
        pros::delay(20);
    }
    left_mg.move_velocity(0);
    right_mg.move_velocity(0);
}

void cordon(double x, double y, double dkd, double dkp, double tkd, double tkp, double theta, double dtimeout, double ttimeout) {
    double difx = x - botx;
    double dify = y - boty;
    double desired_heading = std::atan2(dify, difx) * rad2deg;
    
    while (desired_heading > 180.0) desired_heading -= 360.0;
    while (desired_heading < -180.0) desired_heading += 360.0;
    
    double drive_distance = std::hypot(difx, dify);
    
    turn(desired_heading, tkd, tkp, ttimeout);
    pros::delay(100);
    drive(drive_distance, dkd, dkp, 0, 0, dtimeout); // ignoring ekp/ekd for now
    
    if (theta != 999) { // 999 is magic number for no turn
        turn(theta, tkd, tkp, ttimeout);
    }
}


//auton

void safeautonbottom() {
    // MUST UPDATE BOT STARTING POSITION VAlUES, X = -44.822*conversion_jerry2in, Y = -17.533*conversion_jerry2in, H = 180
    // reset global position manually here if needed
    
    cordon(-54.604*conversion_jerry2in, -46.265*conversion_jerry2in, .5, .5, .2, .2, 180, 3, 3);
    intake(100, true);
    ML.set_value(true);
    pros::delay(100);
    cordon(100000000, -46.265*conversion_jerry2in, .5, .5, .2, .2, 180, 4, 4);
    pros::delay(100);
    cordon(-45.128*conversion_jerry2in, -46.265*conversion_jerry2in, .5, .5, .2, .2, 0, 4, 4);
    pros::delay(100);
    ML.set_value(false);
    cordon(-29.234*conversion_jerry2in, -47.793*conversion_jerry2in, .5, .5, .2, .2, 0, 2.5, 2.5);
    pros::delay(100);
    intake(100, false);
    pros::delay(50);
    score_top(100, true);
}
// void cordon(double x, double y, double dkd, double dkp, double tkd, double tkp, double theta)
void midautonbottom() {

}

void riskautonbottom() {

}

void safeautontop() {

}

void midautontop() {

}

void riskautontop() {

}

void sauton() {

}

void autonomous() {
    turn(180, .5, 3.5, 2);
}
